{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Advanced DataVisualization with ggplot\"\noutput: html_notebook\n---\n\n```{r}\nrequire(ggplot2)\n```\n\n## Advanced DataVisualization with ggplot - Statistics\n\nStats and Genomes\n\nThere are two brought categories:\n\n- those called from within the geom \n- those that are called indipendently\n\nStatistical layers are often already involved in basic Visualization Function in ggplot2.\nFor example in the histogram geometric layer. \n\nUnder the hood this function calls the `stat_bin()` method to create the necessary table. \n```{r}\np <- ggplot(iris, aes(Sepal.Width))\np <- p + geom_histogram()\n\n# Investigating the histogram object\nattributes(p)\n\n# Looking at the layers produces (We see there is a stat_bin layer involved)\np$layers\n\n# Lets take a closer look. This can not be accessed directly\np$layers[[1]]\n```\nUsing the `ggplot_build()` function can help us get access to all intermediate results\n```{r}\nggplot_build(p)$data\n```\n\nThis leads to different possible implementations for the underlying calculation\n```{r}\np <- ggplot(iris, aes(Sepal.Width))\n\n# As a histogram function \np + geom_histogram()\n\n# As a BarPlot\np  + geom_bar()\n\n# Directly with the statistical function call\np + stat_bin(bins = 30)\n```\n\n```{r}\nggplot(mtcars, aes(mpg)) + \n  geom_histogram( fill = \"skyblue\") + \n  geom_freqpoly(col = \"red\")\n```\n\n### Calling the `stat_smooth()` Stats layer directly from within ggplot\n\nWe are using the `geom_smooth()` to attribute the necessary variables to the calculation.\n\n```{r}\n# Fitting individual loess models per Species\nggplot(iris, aes(Sepal.Width, Sepal.Length, col = Species)) + \n  geom_point(position = position_jitter(width = 0.2), alpha = 0.5) + \n  geom_smooth(method = \"loess\", se = TRUE, span = 0.9, alpha = 0.25)\n\n\n# Plotting the data to fit the \"loess\" sliding window mean calculation over all groups\nggplot(iris, aes(Sepal.Width, Sepal.Length, col = Species, group = 1)) + \n  geom_point(position = position_jitter(width = 0.2)) + \n  geom_smooth(method = \"loess\", se = TRUE, span = 0.8, col = \"black\", lty = 2, alpha = 0.3)\n```\n\nAll these fitted models are not predictive in themselfes. They only span the range of given values on the x-Axis. \n\nTo predict over the full range of x-values set, we can set the `fullrange = TRUE` argument. \n```{r}\nggplot(iris, aes(Sepal.Length, Sepal.Width, col = Species)) + \n  geom_point(alpha = 0.6, position = position_jitter(width = 0.2)) + \n  geom_smooth(method = \"lm\", fullrange = TRUE, alpha = 0.15)\n```\n\nThese are all other existing stats functions we will encounter later:\n\nstat_  || geom_\n\nstat_bin() || geom_histogram()\nstat_bin() || geom_bar()\nstat_bin() || geom_freqpoly()\nstat_smooth() || geom_smooth()\nstat_boxplot() || geom_boxplot()\nstat_bindot() || geom_dotplot()\nstat_bin2d() || geom_bin2d()\nstat_binhex() || geom_hex()\nstat_contour() || geom_contour()\nstat_quantile() || geom_quantile()\nstat_sum() || geom_count()\n\n\nYou never have to call these stat_functions directly in ggplot, but understanding their attributes and arguments will enable a more sophisticated control over their behaviour. Enabling better understanding of warning messages and dealing with the respective helpfiles associated with the `stats package`\n\n### Here are some exercises\n\nPlotting both grouped models and a general model\n```{r}\n\n\n# First we plot the basic dataplot\nggplot(mtcars, aes(wt, mpg, col = factor(cyl))) +\n  \n# Then we add a grouped linear model\n  geom_point() + \n  geom_smooth(method = \"lm\", se = F, fullrange = F) + \n  \n# And then add an ungrouped model\n  geom_smooth(method = \"loess\", se = F, aes(group = 1, col = \"All\"), span = 0.7)\n```\n\n\n## Using statistics from outside the ggplot function\n\nSummary statistics, confidence interval calculations etc. can easily be included into the plot trough dedicated ggplot functions, transforming the table results into dataframes and changing their values to be joined into the underlying ggplot 2 calculation dataframes. \n\nMost of the functions called here, are from the `Hmisc()` package. \n\n```{r}\nrequire(Hmisc)\n\n# Calculating a 95% CI\nsmean.cl.normal(xx)\n\n# ggplot2\nmean_cl_normal(xx)\n\n# Applying this to a plot, where it gets plugged into `stat_summary(fun.data= XXX ) argument\nggplot(iris, aes(Species, Sepal.Length)) + \n  stat_summary(fun.data = mean_cl_normal, width = 0.1)\n```\n\nThese functions can give us information on the distribution of our data, useable when working with statistical tests in R, as those make assumptions about the underlying data.\n\n```{r}\n# Summarise y values at distinct x values\nstat_summary()\n\n# Compute y values from a function of x values\nstat_function()\n\n# Perform calculations for a quantile-quantile plot\nstat_qq()\n\n```\n\n\n\n## Calculating a normal distribution to check for model accordance in our data\n```{r}\nlibrary(MASS)\n\n# We plot the normal density against the log linearly transformed dataset to visually inspect the data\nmam.new <- data.frame(body = log10(mammals$body))\nggplot(mam.new, aes(body)) + \n  geom_histogram(aes(y = ..density..), binwidth = 0.2) + \n  geom_rug() + \n  stat_function(fun = dnorm, colour = \"red\",\n                arg = list(mean = mean(mam.new$body),\n                           sd = sd(mam.new$body)))\n\n# Or we use the qqplot to graphically represent it\nmam.new$slope <- diff(quantile(mam.new$body, c(0.25, 0.75))) /\n  diff(qnorm(c(0.25, 0.75)))\n\nmam.new$int <- quantile(mam.new$body, 0.25) - mam.new$slope * qnorm(0.25)\n\nggplot(mam.new, aes(sample = body)) + \n  stat_qq()  + \n  geom_abline(aes(slope = slope, intercept = int), col = \"red\")\n```\n\n```{r}\n# inspecting the dataset\nstr(mtcars)\n\n# Changing the datatstructure\nmtcars$cyl <- as.factor(mtcars$cyl)\nmtcars$am <- as.factor(mtcars$am)\n\n# Define positions to be used\nposn.d <- position_dodge(width = 0.2)\nposn.jd <- position_jitterdodge(jitter.width = 0.1, dodge.width = 0.2)\nposn.j <- position_jitter(width = 0.2)\n\n# Creating plot basic\nwt.cyl.am <- ggplot(mtcars, aes(cyl, wt, col = am, fill = am, group = am))\n```\n\nApplying different stats to this database\n```{r}\n# Plot1: Jiittered, doged scatter plot with transparent points\nwt.cyl.am + \n  geom_point(position = posn.jd, alpha = 0.6)\n\n# Plot2: Mean and SD - the easy way\nwt.cyl.am + \n  geom_point(position = posn.d) + \n  stat_summary(fun.data = mean_sdl, fun.args = list(mult = 1))\n\n# Plot3: Mean and 95% CI - the easy way\nwt.cyl.am + \n  geom_point(position = posn.d) + \n  stat_summary(fun.data = mean_cl_normal)\n\n# Plot4: Mean and SD = with T-tipped error bars\nwt.cyl.am + \n  stat_summary(geom = \"point\", fun.y = mean, \n               position = posn.d) + \n  stat_summary(geom = \"errorbar\", fun.data = mean_sdl,\n               position = posn.d, fun.args = list(mult = 1), width = 0.1)\n```\n\n\nWe can use our own functions to pass to the `fun.data()` call:\n\n```{r}\ngg_range <- function(x){\n  data.frame(ymin = min(x),\n             ymax = max(x))\n}\n\nmed_IQR <- function(x){\n  data.frame(y = median(x),\n             ymin = quantile(x)[2],\n             ymax = quantile(x)[4])\n}\n\n# Now we use these functions on the base plot\nwt.cyl.am + \n  stat_summary(geom = \"linerange\", \n               fun.data = med_IQR, position = posn.d, size = 3) + \n  stat_summary(geom = \"linerange\", fun.data = gg_range,\n               position = posn.d, size = 3,\n               alpha = 0.4) + \n  stat_summary(geom = \"point\", fun.y = median, \n               position = posn.d, size = 3, \n               col = \"black\", shape = \"X\")\n\n```\n\n",
    "created" : 1480781989546.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2232868976",
    "id" : "443AB3F0",
    "lastKnownWriteTime" : 1480946630,
    "last_content_update" : -2147483648,
    "path" : "D:/AAA_ProgrammingFiles/AAA_Learning/DataCamp-R/DatVis with ggplot/DataVis with ggplot2/Statistics.Rmd",
    "project_path" : "Statistics.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}